import math
import graph
import random
import sys
import os
import matplotlib.pyplot as plt
import numpy as np
import time

def timeFunction(func):
    start_time = time.time()
    func()
    return time.time() - start_time

# tests the heuristics on the graphs in the graphs older given by the indices 
def testHeuristics(indices,p1,p2,p3):
    heuristics = ["swap","twoopt","greedy","custom"]
    results = np.zeros((len(indices),len(heuristics)))
    tours = []
    times = np.zeros((len(indices),len(heuristics)))

    for i in range(len(indices)):
        print("Iteration: " + str(i))
        filename  = "graphs/test_"+str(indices[i])
        g = graph.Graph(-1,filename)

        currTours = []
        # swap
        times[i,0] = timeFunction(lambda: g.swapHeuristic())
        results[i,0] = (g.tourValue())
        currTours.append(g.perm)
        g.resetPerm()

        # two-opt
        times[i,1] = timeFunction(lambda: g.TwoOptHeuristic())
        results[i,1] = (g.tourValue())
        currTours.append(g.perm)
        g.resetPerm()  

        # greedy
        times[i,2] = timeFunction(lambda: g.Greedy())
        results[i,2] = (g.tourValue())
        currTours.append(g.perm)
        g.resetPerm() 

        # EPIC
        times[i,3] = timeFunction(lambda:g.EPICHeuristic(p1,p2,p3))
        results[i,3] = (g.tourValue())
        currTours.append(g.perm)

        print([heuristics[x] +':'+ str(round(times[i,x],2)) for x in range(4)])
        tours.append(currTours)
    return (results,np.array(tours),times)

def loadEuclidianGraph(filename):
    f = open(filename,'r')

    X = []
    Y = []
    point = f.readline().strip().split()
    while point != []:
        x,y = point
        X.append(float(x))
        Y.append(float(y))
        point = f.readline().strip().split()
    return (X,Y)

def plotTSP(X,Y,permutation=[],color='b',drawPoints=True):
    # we make sure we, loop around

    ordX = [None] * (len(X) + 1)
    ordY = [None] * (len(Y) + 1)
    if permutation == []:
        ordX = X
        ordY = Y
    else: 
        permutation.append(permutation[0])

        for i,p in enumerate(permutation):
            ordX[i] = X[p]
            ordY[i] = Y[p]
            plt.annotate(str(p),(X[p]-0.5,Y[p]-0.5))

    sequenceColors = ['k' for x in range(len(X))]
    sequenceColors[0] = 'r'
    sequenceColors[1] = 'y'
    sequenceColors[-1] = 'b'
    if drawPoints:
        plt.scatter(ordX[0:-1],ordY[0:-1],c=sequenceColors, zorder=1)
        
    if permutation != []:
        plt.plot(ordX,ordY,color,zorder=0)

# writes files with random graphs with random sizes,and widths (test_n[0],test_n[2],test_n[3].. etc)
# -1 on argument indicates random
def generateTestGraphs(n,sizes):
    for i in range(len(n)):
        nodes = sizes[i]
        width = nodes * 2
        try:
            randomUniformGraph("graphs/test_" + str(n[i]),nodes,width)
        except:
            continue        

# generates random square metric TSP graph, writes it to filename and returns the points
def randomUniformGraph(filename,n,width):
    
    f = open(filename,'x')
    points = set()
    
    while len(points) < n:
        x = int(random.random() * width)
        y = int(random.random() * width)
        points.add((x,y))

    for (x,y) in points:
        f.write(str(x) + " " + str(y) + os.linesep)
    return points

# will graph data for analysis,
# assumes data is in folders named fnames, each containing files:
# results.csv the Nx4 matrix of tour length results
# times.csv the Nx4 matrix of execution times of each heuristic
# tours.npy Nx4x* array tours generated by each heuristic
# cols is a set of up to 4 indices, indicating the heuristics to be compared 
# type
# Bar : 1 = graph average cost of all graphs of each heuritic in each file over the given rows as bar graph
#     : 2 = graph average cost of graph against the size of graph for each heuristic over given rows
#     : 3 = graph the costs of each heuristic from all files for each test number
#     : 4 = graph runtime against test number for each heuristic in each file over given rows
#     : 5 = graph average runtime against the size of graph for each heuristic over given rows
#     : 6 = graph a TSP problem at a single row for up to 4 heuristics
# fnames follow format: ER_s5+1n-10_1_0.5
#                      euclidianRandom/graphs start at 0 nodes add 1 every 5 rows/3 parameters to custom
def graphData(fnames,labels,cols,title,rows=[],type=0,errbars=False,trendLines=False,onlyTrends=False,trendDegree=3):
    # python list containing numpy arrays
    data = []
    routes = []
    names = {0:"swap",1:"twoopt",2:"greedy",3:"custom"}
    colorsH = {0:'#003f5c',1:'#7a5195',2:'#ef5675',3:'#ffa600'}

    for filename in fnames:
        
        fileToUse = ''

        if type == 1 or type == 2 or type == 3:
            fileToUse = "results.csv"
        elif type == 4 or type == 5:
            fileToUse = "times.csv"
        else:
            fileToUse = "tours.npy"

        path = 'results/' + filename + '/'
        try:
            r = np.load(path + "tours.npy",allow_pickle=True)
            d = np.loadtxt(path + fileToUse,delimiter=',')[:,cols]
            
            if rows != []:
                data.append(d[:,rows])
                routes.append(r[:,rows])
            else:
                data.append(d)
                routes.append(r)

        except Exception as E:
            labels[0].pop()
            print(E)
            print("could not load:" + filename + " excluding from graph")
            

    # once we have the data, we pre-process it and graph it
    if type == 1:
        # calculate the averages of each file on the columns
        averages = np.zeros((len(fnames),len(cols)))
        stds = np.zeros((len(fnames),len(cols)))
        for i,d in enumerate(data):
            averages[i] = np.mean(d,axis=0)
            stds[i] = np.std(d,axis=0)
        
        # set parameters
        space_between_subgraphs = 0.5
        sub_bars_num = len(cols)
        sub_bar_width = 0.5/sub_bars_num

        labelsX = np.arange(0,len(fnames))

        fig,ax = plt.subplots()
        
        rects = []
        for i in range(len(cols)):
            offset = sub_bar_width/2 if (sub_bars_num % 2 == 0) else 0

            barHeights = averages[:,i]
            barErrs = stds[:,i]

            barXs = labelsX + offset + ((i - sub_bars_num//2) * sub_bar_width)
            
            rect = None

            if errbars:
                rect = ax.bar(barXs,barHeights,sub_bar_width,yerr=barErrs,color=colorsH[cols[i]],label=names[cols[i]])
            else:
                rect = ax.bar(barXs,barHeights,sub_bar_width,color=colorsH[cols[i]],label=names[cols[i]])
            for i in range(len(barXs)): 
                ax.text(barXs[i], barHeights[i] + 0.05,
                    str(round(barHeights[i],2)),
                    ha='center', va='bottom')
            rects.append(rect)
        
        #  Add some text for labels, title and custom x-axis tick labels, etc.
        ax.set_ylabel('Average Tour Cost')
        ax.set_title(title)
        ax.set_xticks(labelsX)
        ax.set_xticklabels(labels)
        ax.legend()

        fig.tight_layout()
        plt.show()

    elif type == 2 or type == 5:
        # we extract size data, will have len(fnames) entries with lists of test sizes
        sizes = []
        for routeData in routes:
            s = [] 
            for row in routeData:
                s.append(len(row[0]))
            sizes.append(s)

        # now we average the values vertically for rows in data which had the same test graph size
        sizeToRowsList = []
        for i,sizesList in enumerate(sizes):
            sizeToRows = {}
            for j,s in enumerate(sizesList):
                if s in sizeToRows:
                    sizeToRows[s].append(data[i][j])    
                else:
                    sizeToRows[s] = [data[i][j]]
            sizeToRowsList.append(sizeToRows)

        fig,ax = plt.subplots()

        #each different file might have different number of graphs so we graph them separately
        for fileI,sizeToRows in enumerate(sizeToRowsList):
            # now we can iterate over all sizes and graph
            X = np.arange(len(sizeToRows.keys()))
            Y = np.zeros((len(sizeToRows.keys()),len(cols)))
            Stds = np.zeros((len(sizeToRows.keys()),len(cols)))

            for i,s in enumerate(sizeToRows.keys()):
                Y[i] = (np.mean(sizeToRows[s],axis=0))
                Stds[i] = (np.std(sizeToRows[s],axis=0))
            
            for i in range(len(cols)):
                label = labels[fileI] + '-' + names[cols[i]]
                if not(onlyTrends):
                    if errbars:
                        ax.errorbar(X,Y[:,i],yerr=Stds[:,i],label=label)
                    else:
                        ax.plot(X,Y[:,i],label=label)
                    
                if trendLines:
                    # calc the best trendline
                    
                    z = np.polyfit(X, Y[:,i],trendDegree)
                    p = np.poly1d(z)
                    plt.plot(X,p(X),'--',label=poly2latex(p))

        #  Add some text for labels, title and custom x-axis tick labels, etc.
        ylabel = "Average Tour Cost"
        if type == 5:
            ylabel = "Runtime in seconds"

        ax.set_ylabel(ylabel)
        ax.set_xlabel('Number of nodes')
        ax.set_title(title)
        # ax.set_xticks(labelsX)
        # ax.set_xticklabels(labels)
        ax.legend()

        fig.tight_layout()

        plt.show()
    elif type == 3 or type == 4:

        fig,ax = plt.subplots()
        print(data)
        #each different file might have different number of graphs so we graph them separately
        for fileI in range(len(data)):
            # now we can iterate over all sizes and graph
            X = np.arange(len(d))
            Y = None

            print(Y)
            for i in range(len(cols)):
                label = labels[fileI] + '-' + names[cols[i]]
                Y = data[fileI][:,i]

                if not(onlyTrends):
                    if errbars:
                        ax.errorbar(X,Y,yerr=Stds[:,i],label=label)
                    else:
                        ax.plot(X,Y,label=label)
                    
                if trendLines:
                    # calc the best trendline
                    
                    z = np.polyfit(X, Y[:,i],trendDegree)
                    p = np.poly1d(z)
                    plt.plot(X,p(X),'--',label=poly2latex(p))


        #  Add some text for labels, title and custom x-axis tick labels, etc.
        ylabel = "Tour Cost"
        if(type == 4):
            ylabel = "Runtime in seconds"
        ax.set_ylabel(ylabel)
        ax.set_xlabel('Test Number')
        ax.set_title(title)
        ax.legend()

        fig.tight_layout()

        plt.show()
  
    elif type == 5:
        #we graph runtimes
        return
    else:
        return
    return
#tests.graphData(["ER_s5+1n-10_1_0","ER_s5+1n-10_1_0.5"],["0","0.5"],(0,1,2,3),"blag",[],type=1)
#tests.graphData(["ER_s5+1n-10_1_0",
            #   "ER_s5+1n-10_1_0.1",
            #   "ER_s5+1n-10_1_0.2",
            #   "ER_s5+1n-10_1_0.3",
            #   "ER_s5+1n-10_1_0.4",
            #   "ER_s5+1n-10_1_0.4",
            #   "ER_s5+1n-10_1_0.5",
            #   "ER_s5+1n-10_1_0.6",
            #   "ER_s5+1n-10_1_0.7",
            #   "ER_s5+1n-10_1_0.8",
            #   "ER_s5+1n-10_1_0.9",
            #   "ER_s5+1n-10_1_1"],[str(0.1*x) for x in range(11)],[3],"b",[],type=1)

if __name__ == "__main__":
    testName= "ER_s5+1n-0_1_0.5"
    os.makedirs(("results/" + testName), exist_ok=True)

    (results,tours,times) = testHeuristics([x for x in range(500)],0,1,0.5)

    np.savetxt('results/'+testName+'/results.csv',results,delimiter=',')
    np.save('results/'+testName+'/tours.npy',tours,allow_pickle=True)
    np.savetxt('results/'+testName+'/times.csv',times,delimiter=',')
        

# def poly2latex(poly, variable="x", width=2):
#     t = ["{0:0.{width}f}"]
#     t.append(t[-1] + " {variable}")
#     t.append(t[-1] + "^{1}")

#     def f():
#         for i, v in enumerate(reversed(poly)):
#             idx = i if i < 2 else 2
#             yield t[idx].format(v, i, variable=variable, width=width)

#     return "${}$".format("+".join(f()))

def poly2latex(p):
    coefs = p.coef  # List of coefficient, sorted by increasing degrees
    res = ""  # The resulting string
    for i, a in enumerate(coefs):
        if int(a) == a:  # Remove the trailing .0
            a = int(a)
        if i == 0:  # First coefficient, no need for X
            if a > 0:
                res += "{a} + ".format(a=np.format_float_scientific(a,exp_digits=1,precision=1))
            elif a < 0:  # Negative a is printed like (a)
                res += "({a}) + ".format(a=np.format_float_scientific(a,exp_digits=1,precision=1))
            # a = 0 is not displayed 
        elif i == 1:  # Second coefficient, only X and not X**i
            if a == 1:  # a = 1 does not need to be displayed
                res += "X + "
            elif a > 0:
                res += "{a} \;X + ".format(a=np.format_float_scientific(a,exp_digits=1,precision=1))
            elif a < 0:
                res += "({a}) \;X + ".format(a=np.format_float_scientific(a,exp_digits=1,precision=1))
        else:
            if a == 1:
                # A special care needs to be addressed to put the exponent in {..} in LaTeX
                res += "X^{i} + ".format(i="{%d}" % i)
            elif a > 0:
                res += "{a} \;X^{i} + ".format(a=np.format_float_scientific(a,exp_digits=1,precision=1), i="{%d}" % i)
            elif a < 0:
                res += "({a}) \;X^{i} + ".format(a=np.format_float_scientific(a,exp_digits=1,precision=1), i="{%d}" % i)
    return "$" + res[:-3] + "$" if res else ""