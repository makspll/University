import math
import graph
import random
import sys
import os
import matplotlib.pyplot as plt
import numpy as np
import time

def timeFunction(func):
    start_time = time.time()
    func()
    return time.time() - start_time

# tests the heuristics on the graphs in the graphs older given by the indices 
def testHeuristics(indices,p1,p2,p3):
    heuristics = ["swap","twoopt","greedy","custom"]
    results = np.zeros((len(indices),len(heuristics)))
    tours = []
    times = np.zeros((len(indices),len(heuristics)))

    for i in range(len(indices)):
        print("Iteration: " + str(i))
        filename  = "graphs/test_"+str(indices[i])
        g = graph.Graph(-1,filename)

        currTours = []
        # swap
        times[i,0] = timeFunction(lambda: g.swapHeuristic())
        results[i,0] = (g.tourValue())
        currTours.append(g.perm)
        g.resetPerm()

        # two-opt
        times[i,1] = timeFunction(lambda: g.TwoOptHeuristic())
        results[i,1] = (g.tourValue())
        currTours.append(g.perm)
        g.resetPerm()  

        # greedy
        times[i,2] = timeFunction(lambda: g.Greedy())
        results[i,2] = (g.tourValue())
        currTours.append(g.perm)
        g.resetPerm() 

        # EPIC
        times[i,3] = timeFunction(lambda:g.EPICHeuristic(p1,p2,p3))
        results[i,3] = (g.tourValue())
        currTours.append(g.perm)

        print([heuristics[x] +':'+ str(round(times[i,x],2)) for x in range(4)])
        tours.append(currTours)
    return (results,np.array(tours),times)

def loadEuclidianGraph(filename):
    f = open(filename,'r')

    X = []
    Y = []
    point = f.readline().strip().split()
    while point != []:
        x,y = point
        X.append(float(x))
        Y.append(float(y))
        point = f.readline().strip().split()
    return (X,Y)

def plotTSP(X,Y,permutation=[],color='b',drawPoints=True):
    # we make sure we, loop around

    ordX = [None] * (len(X) + 1)
    ordY = [None] * (len(Y) + 1)
    if permutation == []:
        ordX = X
        ordY = Y
    else: 
        permutation.append(permutation[0])

        for i,p in enumerate(permutation):
            ordX[i] = X[p]
            ordY[i] = Y[p]
            plt.annotate(str(p),(X[p]-0.5,Y[p]-0.5))

    sequenceColors = ['k' for x in range(len(X))]
    sequenceColors[0] = 'r'
    sequenceColors[1] = 'y'
    sequenceColors[-1] = 'b'
    if drawPoints:
        plt.scatter(ordX[0:-1],ordY[0:-1],c=sequenceColors, zorder=1)
        
    if permutation != []:
        plt.plot(ordX,ordY,color,zorder=0)

# writes files with random graphs with random sizes,and widths (test_n[0],test_n[2],test_n[3].. etc)
# -1 on argument indicates random
def generateTestGraphs(n,sizes):
    for i in n:
        nodes = sizes[i]
        width = nodes * 2
        try:
            randomUniformGraph("graphs/test_" + str(i),nodes,width)
        except:
            continue        

# generates random square metric TSP graph, writes it to filename and returns the points
def randomUniformGraph(filename,n,width):
    
    f = open(filename,'x')
    points = set()
    
    while len(points) < n:
        x = int(random.random() * width)
        y = int(random.random() * width)
        points.add((x,y))

    for (x,y) in points:
        f.write(str(x) + " " + str(y) + os.linesep)
    return points

# will graph data for analysis,
# assumes data is in folders named fnames, each containing files:
# results.csv the Nx4 matrix of tour length results
# times.csv the Nx4 matrix of execution times of each heuristic
# tours.npy Nx4x* array tours generated by each heuristic
# cols is a set of up to 4 indices, indicating the heuristics to be compared 
# type: 1 = graph average cost of all graphs of each heuritic in each file over the given rows
#     : 2 = graph average cost of graph against the size of graph for each heuristic in each file over given rows
#     : 3 = graph average runtime against graph size for each heuristic in each file over given rows
#     : 4 = plot a TSP graph and plot the tours of each heuristic in cols, for the graphs in rows
# fnames follow format: ER_s5+1n-10_1_0.5
#                      euclidianRandom/graphs start at 0 nodes add 1 every 5 rows/3 parameters to custom
def graphData(fnames,labels,cols,title,rows=[],type=0):
    # python list containing numpy arrays
    data = []
    names = {0:"swap",1:"twoopt",2:"greedy",3:"custom"}
    colorsH = {0:'#003f5c',1:'#7a5195',2:'#ef5675',3:'#ffa600'}

    for filename in fnames:
        
        fileToUse = ''

        if type == 1 or type == 2:
            fileToUse = "results.csv"
        elif type == 3:
            fileToUse = "times.csv"
        else:
            fileToUse = "tours.npy"

        path = 'results/' + filename + '/' + fileToUse
        try:
            d = None
            if type == 3:
                d = np.load(path,allow_pickle=True)
            else:
                d = np.loadtxt(path,delimiter=',',usecols=cols)
            if rows != []:
                data.append(d[:,rows])
            else:
                data.append(d)
        except Exception as E:
            print(E)
            print("could not load:" + filename + " excluding from graph")
            

    # once we have the data, we pre-process it and graph it
    if type == 1:
        # calculate the averages of each file on the columns
        averages = np.zeros((len(fnames),len(cols)))
        stds = np.zeros((len(fnames),len(cols)))
        for i,d in enumerate(data):
            averages[i] = np.mean(d,axis=0)
            stds[i] = np.std(d,axis=0)
        
        # set parameters
        space_between_subgraphs = 0.5
        sub_bars_num = len(cols)
        sub_bar_width = 0.5/sub_bars_num

        labelsX = np.arange(0,len(fnames))

        fig,ax = plt.subplots()
        
        rects = []
        for i in range(len(cols)):
            offset = sub_bar_width/2 if (sub_bars_num % 2 == 0) else 0

            barHeights = averages[:,i]

            barXs = labelsX + offset + ((i - sub_bars_num//2) * sub_bar_width)
            print(barErrs)
            rect = ax.bar(barXs,barHeights,sub_bar_width,color=colorsH[cols[i]],label=names[cols[i]])
            for i in range(len(barXs)): 
                ax.text(barXs[i], barHeights[i] + 0.05,
                    str(round(barHeights[i],2)),
                    ha='center', va='bottom')
            rects.append(rect)
        
        #  Add some text for labels, title and custom x-axis tick labels, etc.
        ax.set_ylabel('Average Tour Cost')
        ax.set_title('Average Tour Costs From All Tests')
        ax.set_xticks(labelsX)
        ax.set_xticklabels(labels)
        ax.legend()

        fig.tight_layout()
        plt.show()

    elif type == 2:

        return
    elif type == 3:
        return
    elif type == 4:
        return
    else:
        return
    return
#tests.graphData(["ER_s5+1n-10_1_0","ER_s5+1n-10_1_0.5"],["0","0.5"],(0,1,2,3),"blag",[],type=1)
#tests.graphData(["ER_s5+1n-10_1_0",
            #   "ER_s5+1n-10_1_0.1",
            #   "ER_s5+1n-10_1_0.2",
            #   "ER_s5+1n-10_1_0.3",
            #   "ER_s5+1n-10_1_0.4",
            #   "ER_s5+1n-10_1_0.4",
            #   "ER_s5+1n-10_1_0.5",
            #   "ER_s5+1n-10_1_0.6",
            #   "ER_s5+1n-10_1_0.7",
            #   "ER_s5+1n-10_1_0.8",
            #   "ER_s5+1n-10_1_0.9",
            #   "ER_s5+1n-10_1_1"],[str(0.1*x) for x in range(11)],[3],"b",[],type=1)

#  if __name__ == "__main__":
    # testName= "ER_s5+1n-10000_1_0.5"
    # os.makedirs(("results/" + testName), exist_ok=True)

    # (results,tours,times) = testHeuristics([x for x in range(500)],10000,1,0.5)
    
    # np.savetxt('results/'+testName+'/results.csv',results,delimiter=',')
    # np.save('results/'+testName+'/tours.npy',tours,allow_pickle=True)
    # np.savetxt('results/'+testName+'/times.csv',times,delimiter=',')
    
