\documentclass{article}

\usepackage{Custom_Latex/Summary_Notes/notes}
\usepackage{array}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{graphicx}
\usepackage{amssymb}
\graphicspath{{./Images/}}

\everymath{\displaystyle}
\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}

\begin{document}
\title{IADS - Summary Notes}
\author{Maksymilian Mozolewski}
\maketitle
\pagebreak
\tableofcontents
\pagebreak
% SEMESTER 1 %
% WEEK 1 %
% TUTORIAL - DONE %
\section{Introduction}
\nDefinition{Algorithm}{
a mathematical abstraction of a computer program. with the programming language represented as pseudocode/structured english and the computer being represented by a \bd{model of computation}}
\subsection{Model of Computation}
\nDefinition{Definition}{
specifies what operations an algorithm is allowed and how much they cost (time, etc)}
\subsubsection{Random access machine}
\nDefinition{Definition}{A simple computation model which uses Random Access memory\par
\bd{memory} - constant time loads, computations and stores}  
\subsubsection{Pointer Machine}
\nDefinition{Definition}{
dynamically allocated objects, an object has a constant number of fields, a field is either a word or a pointer.}
\subsubsection{Python Model}
\nDefinition{Definition}{
"list" = array\par
objects with constant attributes(constant time access)\par
append - constant time\par
concat - $O(m + n)$ time\par
'in' - linear time\par
sort - $O(nlog(n))$\par
dictionary - mostly linear time\par 
long addition - $O(n + m)$\par
long multiplication - $O(m + n)^{log(3)}$\par
}
% DAY - TUESDAY %
% LECTURE - 3 %
% READING - 100% %
% NOTES_COMPLETE - %
\section{Basic Sorting}
\subsection{Insertion Sort}
\subsection{Merge Sort} 
% LECTURE - 3 %
% READING - 100% %
% NOTES_COMPLETE - %
\section{Data Structures}
\subsection{Priority Queue}
\nDefinition{Definition}{
set of elements with their priorities, operations performed are: taking elements out with the highest priority, changing priorities etc}
% SEMESTER 2 %
% WEEK 2 %
% TUTORIAL - DONE %

% DAY - TUESDAY %
% LECTURE - 1 %
% READING - 100% %
% NOTES_COMPLETE - %
\section{Algorithm Techqniques}
\subsection{Divide \& Conquer}
\nDefinition{Definition}{
The technique when we design an algorithm to solve a problem by taking an instance \emph{I} (of size n), then:
\begin{itemize}
    \item divide the problem into k smaller subproblems
    \item Making k recursive calls to obtain the answer for the sub-problems
    \item Take answers from 2. and do some computation to get the overall answer for the original input I.
\end{itemize}

Details will vary (the number k, how to combine answers etc.)\par
in some cases, Divide-and-Conquer can give rise to an efficient (Polynomial time) algorithm - for example Mergesort, Quicksort.\par
\bd{Master Theorem} - often features in the analysis. \par
but not always effective.
}
\subsubsection{Toy Example}
\nDefinition{Fibonacci numbers}{
The Fibonacci numbers are defined as: 
\begin{gather*}
    F_{0} = 0,\\
    F_{1} = 1,\\
    F_{n} = F_{n-1} + F_{n-2}\text{    } (for n \geq 2)
\end{gather*}
There is an immediate recursive algorithm:
\bd{Algorithm Rec-Fib}(n)\par
\bd{if} n = 0 \bd{then}\\
\hspace*{15pt} \bd{return} 0
\par
\begin{equation*}
    T(n) = T(n-1) + T(n-2) + \theta(1) \geq F_{n} =(aprox) (1.6)^{n}
\end{equation*}
}
\nDefinition{Dynamic Approach}{
\bd{Algorithm} Dyn-Fib(n)\\
$F[0] = 0$\\
$F[1] = 1$\\
\bd{for} $i \leftarrow 2$ \bd{to} n \bd{do}\\
\hspace*{15pt} $F[i] \leftarrow F[i-1] + F[i-2]$\\
\bd{return} $F[n]$\\
build from the bottom up. \par
we are turning the recursion upside down. \par\bigskip
running time is \bd{$\theta(n)$}
}
\nDefinition{coin-changing problem}{
in the UK coins have denominations 1p, 2p, 5p, 10p, 20p, 50p, 1£ and £2\par
A frequently-executed task in the retail sector involves taking an input value and calculating a collection of coins (may include duplicates) which will sum to that value. \par
We assume an unlimited supply of coins of each value \par
The \bd{coin problem} is the problem, given an input value v ($v \in \mathbb{N_{0}}$)of calculating a collection of coins (of minimum cardinality) that will sum to v\par
Observation: there is a coin which belongs to the optimal solution, and knowing that: 
\begin{equation*}
    C(v) = 1 + C(v - c_{i})
\end{equation*}}
\nDefinition{Edit distance via Dynamic Programming}{
\bd{Edit Distance} - number of mutations to get from one string to another where mutations can be: substitutions, insertions and deletions}
\subsection{Dynamic Programming}
\nDefinition{asdasd}{dasadss}

% DAY - X %
% LECTURE - 2 %
% READING -  %
% NOTES_COMPLETE -  %
\section{}
\end{document}